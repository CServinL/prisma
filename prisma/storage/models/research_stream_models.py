"""
Research Stream Data Models

This module defines Pydantic models for Research Streams - persistent research topics
that leverage Zotero Collections and Tags for organization and continuous monitoring.
"""

from typing import List, Dict, Any, Optional, Set
from datetime import datetime, timedelta
from enum import Enum
from pydantic import BaseModel, Field, field_validator, ConfigDict

from .zotero_models import ZoteroCollection, ZoteroItem, ZoteroTag


class RefreshFrequency(str, Enum):
    """How often to refresh a research stream"""
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    MANUAL = "manual"


class StreamStatus(str, Enum):
    """Status of a research stream"""
    ACTIVE = "active"
    PAUSED = "paused"
    ARCHIVED = "archived"


class TagCategory(str, Enum):
    """Categories of tags for smart organization"""
    PRISMA = "prisma"      # Auto-generated by Prisma
    TEMPORAL = "temporal"   # Year, recency
    METHODOLOGY = "methodology"  # Survey, empirical, theoretical
    STATUS = "status"      # to-read, key-paper, cited-in-report
    QUALITY = "quality"    # high-impact, peer-reviewed
    SOURCE = "source"      # Where the paper came from


class SmartTag(BaseModel):
    """A tag with category and metadata"""
    model_config = ConfigDict(str_strip_whitespace=True)
    
    name: str = Field(..., description="Tag name")
    category: TagCategory = Field(..., description="Tag category")
    auto_generated: bool = Field(default=False, description="Whether tag was auto-generated")
    description: Optional[str] = Field(None, description="Tag description")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError("Tag name cannot be empty")
        return v.lower().strip()


class SearchCriteria(BaseModel):
    """Search criteria for a research stream"""
    model_config = ConfigDict(str_strip_whitespace=True)
    
    query: str = Field(..., description="Main search query")
    tags: List[str] = Field(default_factory=list, description="Required tags")
    exclude_tags: List[str] = Field(default_factory=list, description="Tags to exclude")
    item_types: List[str] = Field(default_factory=list, description="Item types to include")
    since_date: Optional[datetime] = Field(None, description="Only papers after this date")
    max_results: int = Field(default=100, description="Maximum results per search")
    
    @field_validator('query')
    @classmethod
    def validate_query(cls, v):
        if not v or not v.strip():
            raise ValueError("Search query cannot be empty")
        return v.strip()


class ResearchStream(BaseModel):
    """
    A Research Stream represents a persistent research topic that continuously
    monitors for new papers using Zotero Collections and smart tagging.
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    # Core Identity
    id: str = Field(..., description="Unique identifier for the stream")
    name: str = Field(..., description="Human-readable name")
    description: Optional[str] = Field(None, description="Detailed description")
    
    # Zotero Integration
    collection_key: Optional[str] = Field(None, description="Zotero collection key")
    collection_name: str = Field(..., description="Zotero collection name")
    parent_collection_key: Optional[str] = Field(None, description="Parent collection key")
    
    # Search Configuration
    search_criteria: SearchCriteria = Field(..., description="How to find papers")
    smart_tags: List[SmartTag] = Field(default_factory=list, description="Auto-applied tags")
    
    # Monitoring
    status: StreamStatus = Field(default=StreamStatus.ACTIVE, description="Stream status")
    refresh_frequency: RefreshFrequency = Field(default=RefreshFrequency.WEEKLY, description="Update frequency")
    last_updated: Optional[datetime] = Field(None, description="Last refresh time")
    next_update: Optional[datetime] = Field(None, description="Next scheduled update")
    
    # Statistics
    total_papers: int = Field(default=0, description="Total papers in stream")
    new_papers_last_update: int = Field(default=0, description="Papers added in last update")
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow, description="Creation time")
    created_by: str = Field(default="prisma", description="Creator")
    
    @field_validator('name')
    @classmethod
    def validate_name(cls, v):
        if not v or not v.strip():
            raise ValueError("Stream name cannot be empty")
        return v.strip()
    
    @field_validator('id')
    @classmethod
    def validate_id(cls, v):
        if not v or not v.strip():
            raise ValueError("Stream ID cannot be empty")
        # Ensure ID is URL-safe
        import re
        if not re.match(r'^[a-zA-Z0-9_-]+$', v):
            raise ValueError("Stream ID must contain only letters, numbers, underscores, and hyphens")
        return v.lower().strip()
    
    def calculate_next_update(self) -> datetime:
        """Calculate when the next update should occur"""
        base_time = self.last_updated or self.created_at
        
        if self.refresh_frequency == RefreshFrequency.DAILY:
            return base_time + timedelta(days=1)
        elif self.refresh_frequency == RefreshFrequency.WEEKLY:
            return base_time + timedelta(weeks=1)
        elif self.refresh_frequency == RefreshFrequency.MONTHLY:
            return base_time + timedelta(days=30)
        else:  # MANUAL
            return base_time + timedelta(days=365)  # Far future
    
    def is_due_for_update(self) -> bool:
        """Check if stream is due for an update"""
        if self.status != StreamStatus.ACTIVE:
            return False
        if self.refresh_frequency == RefreshFrequency.MANUAL:
            return False
        return datetime.utcnow() >= (self.next_update or self.calculate_next_update())
    
    def get_prisma_tags(self) -> List[str]:
        """Get all Prisma-generated tags for this stream"""
        prisma_tags = [
            f"prisma-{self.id}",
            f"stream-{self.id}",
            "prisma-auto"
        ]
        
        # Add temporal tags
        if self.created_at:
            prisma_tags.append(f"created-{self.created_at.year}")
        
        # Add status tags
        prisma_tags.append(f"status-{self.status.value}")
        
        return prisma_tags
    
    def to_zotero_collection(self) -> Dict[str, Any]:
        """Convert to Zotero collection format"""
        return {
            "name": self.collection_name,
            "parentCollection": self.parent_collection_key or False,
            "relations": {}
        }


class StreamUpdateResult(BaseModel):
    """Result of updating a research stream"""
    model_config = ConfigDict()
    
    stream_id: str = Field(..., description="Stream ID")
    success: bool = Field(..., description="Whether update was successful")
    new_papers_found: int = Field(default=0, description="New papers added")
    errors: List[str] = Field(default_factory=list, description="Any errors encountered")
    duration_seconds: float = Field(default=0.0, description="Update duration")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Update time")


class StreamSummary(BaseModel):
    """Summary information about research streams"""
    model_config = ConfigDict()
    
    total_streams: int = Field(default=0, description="Total number of streams")
    active_streams: int = Field(default=0, description="Number of active streams")
    total_papers: int = Field(default=0, description="Total papers across all streams")
    streams_due_update: int = Field(default=0, description="Streams needing updates")
    last_global_update: Optional[datetime] = Field(None, description="Last system-wide update")